---
phase: 01-core-cli-integration
plan: 02
type: execute
wave: 2
depends_on: [01-01]
files_modified:
  - src/tools/handlers.ts
  - src/tools/definitions.ts
  - src/server.ts
  - src/index.ts
autonomous: true
requirements: [TOOL-01, TOOL-02, TOOL-03, TOOL-04, TOOL-05, TOOL-06, TOOL-07, CLI-01, CLI-02, CLI-03, CLI-04, SEC-02]

must_haves:
  truths:
    - "Calling the ask tool invokes `copilot -p <prompt>` with all required base flags and reads the response from stdout"
    - "Calling the suggest tool with optional target param constructs the correct prompt prefix for shell/git/gh scope"
    - "Calling the explain tool wraps the command in a plain-language prompt and returns stdout"
    - "Calling the ping tool returns a live confirmation without invoking the copilot binary"
    - "All three AI tools accept model and addDir parameters; addDir is validated (no null bytes, no ../traversal, absolute path only)"
    - "npm run build succeeds with zero TypeScript errors"
  artifacts:
    - path: "src/tools/handlers.ts"
      provides: "AskToolHandler, SuggestToolHandler, ExplainToolHandler, PingToolHandler, toolHandlers registry"
      contains: "COPILOT_BASE_ARGS"
      min_lines: 80
    - path: "src/tools/definitions.ts"
      provides: "Tool definitions array with 4 tools: ask, suggest, explain, ping"
      contains: "suggest"
    - path: "src/server.ts"
      provides: "CopilotMcpServer class"
      contains: "CopilotMcpServer"
    - path: "src/index.ts"
      provides: "Entry point importing CopilotMcpServer"
      contains: "CopilotMcpServer"
  key_links:
    - from: "src/tools/handlers.ts"
      to: "src/utils/command.ts"
      via: "executeCommand('copilot', args, undefined, { strictExitCode: true })"
      pattern: "strictExitCode.*true"
    - from: "src/tools/handlers.ts"
      to: "stdout as response"
      via: "result.stdout.trim() — NOT result.stderr"
      pattern: "result\\.stdout"
    - from: "src/tools/definitions.ts"
      to: "src/types.ts TOOLS constant"
      via: "import { TOOLS } from '../types.js'"
      pattern: "TOOLS\\.ASK|TOOLS\\.SUGGEST|TOOLS\\.EXPLAIN|TOOLS\\.PING"
    - from: "src/server.ts"
      to: "toolHandlers registry"
      via: "import from ./tools/handlers.js"
      pattern: "CopilotMcpServer"
---

<objective>
Rewrite the tool handler and definition layers, and update the server entry points. This is the core behavioral change: four new stateless handler classes invoking the standalone `copilot` binary via `-p` flag with hardcoded safety flags, reading responses from stdout, with addDir path validation (SEC-02).

Purpose: Deliver the working four-tool set (ask, suggest, explain, ping) against the real copilot CLI. Restore a compilable codebase.
Output: Rewritten handlers.ts and definitions.ts; updated server.ts and index.ts; `npm run build` passes.
</objective>

<execution_context>
@/Users/jonathanborduas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonathanborduas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-cli-integration/01-RESEARCH.md
@.planning/phases/01-core-cli-integration/01-01-SUMMARY.md
@src/types.ts
@src/utils/command.ts
@src/errors.ts
@src/tools/handlers.ts
@src/tools/definitions.ts
@src/server.ts
@src/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite src/tools/handlers.ts with four Copilot tool handlers</name>
  <files>src/tools/handlers.ts</files>
  <action>
    Fully rewrite `src/tools/handlers.ts`. Delete all existing content. Write the following:

    **Imports:**
    ```typescript
    import path from 'path';
    import { z } from 'zod';
    import {
      TOOLS,
      DEFAULT_COPILOT_MODEL,
      COPILOT_DEFAULT_MODEL_ENV_VAR,
      AskToolSchema,
      SuggestToolSchema,
      ExplainToolSchema,
      PingToolSchema,
      type ToolResult,
      type ToolHandlerContext,
    } from '../types.js';
    import { executeCommand } from '../utils/command.js';
    import { ToolExecutionError, ValidationError } from '../errors.js';
    ```

    **Default context:**
    ```typescript
    const defaultContext: ToolHandlerContext = {
      sendProgress: async () => {},
    };
    ```

    **Base args constant (CLI-03 hardcoded flags):**
    ```typescript
    const COPILOT_BASE_ARGS = [
      '--allow-all-tools',
      '--no-ask-user',
      '--silent',
      '--no-color',
      '--no-auto-update',
    ] as const;
    ```

    **addDir validator (SEC-02):**
    ```typescript
    function validateAddDir(addDir: string): void {
      if (addDir.includes('\0')) {
        throw new ValidationError('addDir', 'addDir contains null bytes');
      }
      if (addDir.split('/').includes('..')) {
        throw new ValidationError('addDir', 'addDir must not contain path traversal segments');
      }
      if (!path.isAbsolute(addDir)) {
        throw new ValidationError('addDir', 'addDir must be an absolute path');
      }
    }
    ```

    **Arg builder (CLI-01, CLI-02, CLI-03, TOOL-06, TOOL-07):**
    ```typescript
    function buildCopilotArgs(prompt: string, model?: string, addDir?: string): string[] {
      const resolvedModel =
        model ?? process.env[COPILOT_DEFAULT_MODEL_ENV_VAR] ?? DEFAULT_COPILOT_MODEL;
      const args: string[] = ['-p', prompt, ...COPILOT_BASE_ARGS, '--model', resolvedModel];
      if (addDir) {
        validateAddDir(addDir);
        args.push('--add-dir', addDir);
      }
      return args;
    }
    ```

    **Prompt builders (TOOL-02, TOOL-03, TOOL-04):**
    ```typescript
    function buildSuggestPrompt(prompt: string, target?: 'shell' | 'git' | 'gh'): string {
      if (!target) return `Suggest a command to accomplish: ${prompt}`;
      const labels: Record<string, string> = {
        shell: 'shell',
        git: 'git',
        gh: 'GitHub CLI (gh)',
      };
      return `Suggest a ${labels[target]} command to accomplish: ${prompt}`;
    }

    function buildExplainPrompt(command: string): string {
      return `Explain what this command does: ${command}`;
    }
    ```

    **Handler response helper:**
    ```typescript
    function extractResponse(stdout: string, stderr: string, toolName: string): string {
      const response = stdout.trim();
      if (!response && stderr) {
        throw new ToolExecutionError(toolName, `Copilot error: ${stderr}`);
      }
      return response || 'No response from Copilot';
    }
    ```

    **AskToolHandler (TOOL-01, CLI-01, CLI-02, CLI-03, CLI-04):**
    ```typescript
    export class AskToolHandler {
      async execute(args: unknown, context: ToolHandlerContext = defaultContext): Promise<ToolResult> {
        const { prompt, model, addDir } = AskToolSchema.parse(args);
        const cmdArgs = buildCopilotArgs(prompt, model, addDir);
        try {
          const result = await executeCommand('copilot', cmdArgs, undefined, { strictExitCode: true });
          return { content: [{ type: 'text', text: extractResponse(result.stdout, result.stderr, TOOLS.ASK) }] };
        } catch (error) {
          if (error instanceof ValidationError) throw error;
          throw new ToolExecutionError(TOOLS.ASK, 'Failed to execute copilot ask', error);
        }
      }
    }
    ```

    **SuggestToolHandler (TOOL-02, TOOL-03):**
    ```typescript
    export class SuggestToolHandler {
      async execute(args: unknown, context: ToolHandlerContext = defaultContext): Promise<ToolResult> {
        const { prompt, target, model, addDir } = SuggestToolSchema.parse(args);
        const cmdArgs = buildCopilotArgs(buildSuggestPrompt(prompt, target), model, addDir);
        try {
          const result = await executeCommand('copilot', cmdArgs, undefined, { strictExitCode: true });
          return { content: [{ type: 'text', text: extractResponse(result.stdout, result.stderr, TOOLS.SUGGEST) }] };
        } catch (error) {
          if (error instanceof ValidationError) throw error;
          throw new ToolExecutionError(TOOLS.SUGGEST, 'Failed to execute copilot suggest', error);
        }
      }
    }
    ```

    **ExplainToolHandler (TOOL-04):**
    ```typescript
    export class ExplainToolHandler {
      async execute(args: unknown, context: ToolHandlerContext = defaultContext): Promise<ToolResult> {
        const { command, model, addDir } = ExplainToolSchema.parse(args);
        const cmdArgs = buildCopilotArgs(buildExplainPrompt(command), model, addDir);
        try {
          const result = await executeCommand('copilot', cmdArgs, undefined, { strictExitCode: true });
          return { content: [{ type: 'text', text: extractResponse(result.stdout, result.stderr, TOOLS.EXPLAIN) }] };
        } catch (error) {
          if (error instanceof ValidationError) throw error;
          throw new ToolExecutionError(TOOLS.EXPLAIN, 'Failed to execute copilot explain', error);
        }
      }
    }
    ```

    **PingToolHandler (TOOL-05):**
    ```typescript
    export class PingToolHandler {
      async execute(_args: unknown, _context: ToolHandlerContext = defaultContext): Promise<ToolResult> {
        return {
          content: [{ type: 'text', text: 'Copilot MCP Server is running.' }],
        };
      }
    }
    ```

    **Handler registry:**
    ```typescript
    export const toolHandlers = {
      [TOOLS.ASK]: new AskToolHandler(),
      [TOOLS.SUGGEST]: new SuggestToolHandler(),
      [TOOLS.EXPLAIN]: new ExplainToolHandler(),
      [TOOLS.PING]: new PingToolHandler(),
    } as const;
    ```

    CRITICAL: Do NOT use `result.stderr` as the primary response anywhere. The `extractResponse` function throws when stdout is empty and stderr is non-empty. This is the stdout/stderr inversion fix (CLI-04).

    CRITICAL: All handler classes are stateless — no constructor parameters. No session storage references anywhere.

    CRITICAL: `executeCommand('copilot', ...)` is the invocation — not `gh copilot` (CLI-01).
  </action>
  <verify>
    `npx tsc --noEmit 2>&1 | grep "handlers.ts"` — zero TypeScript errors.
    `grep "result\.stderr" src/tools/handlers.ts` — should return zero results (stderr is only referenced inside extractResponse as an error signal, not as a response).
    `grep "strictExitCode.*true" src/tools/handlers.ts` — found in each handler.
    `grep "COPILOT_BASE_ARGS\|--allow-all-tools\|--no-ask-user\|--silent\|--no-color\|--no-auto-update" src/tools/handlers.ts` — all flags present.
    `grep "session" src/tools/handlers.ts` — zero results.
  </verify>
  <done>handlers.ts exports AskToolHandler, SuggestToolHandler, ExplainToolHandler, PingToolHandler, and toolHandlers registry; all handlers are stateless; stdout is the primary response; all base flags are hardcoded; addDir is validated; TypeScript compiles with zero errors in this file</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite src/tools/definitions.ts and update server.ts + index.ts</name>
  <files>
    src/tools/definitions.ts
    src/server.ts
    src/index.ts
  </files>
  <action>
    **src/tools/definitions.ts — full rewrite:**

    Replace all content with four tool definitions (ask, suggest, explain, ping). Each must conform to the existing `ToolDefinition` type from `../types.js`.

    ```typescript
    import { TOOLS, type ToolDefinition } from '../types.js';

    export const toolDefinitions: ToolDefinition[] = [
      {
        name: TOOLS.ASK,
        description:
          'Ask GitHub Copilot a question or give it a task using natural language. ' +
          'Copilot runs in agent mode with --allow-all-tools enabled, meaning it can execute ' +
          'shell commands and read files on your behalf. Use this for open-ended coding questions, ' +
          'code generation, refactoring guidance, or any task requiring Copilot\'s full capabilities.',
        inputSchema: {
          type: 'object',
          properties: {
            prompt: { type: 'string', description: 'The natural language prompt or question for Copilot' },
            model: { type: 'string', description: 'AI model to use (default: gpt-4.1). Example: gpt-4o, claude-sonnet-4-5' },
            addDir: { type: 'string', description: 'Absolute path to an additional directory to expose to the Copilot agent' },
          },
          required: ['prompt'],
        },
      },
      {
        name: TOOLS.SUGGEST,
        description:
          'Ask GitHub Copilot to suggest a shell, git, or gh CLI command for a given task. ' +
          'Use the optional target parameter to scope the suggestion type.',
        inputSchema: {
          type: 'object',
          properties: {
            prompt: { type: 'string', description: 'Describe what you want to accomplish' },
            target: {
              type: 'string',
              enum: ['shell', 'git', 'gh'],
              description: 'Scope the command suggestion: shell (default), git, or gh (GitHub CLI)',
            },
            model: { type: 'string', description: 'AI model to use (default: gpt-4.1)' },
            addDir: { type: 'string', description: 'Absolute path to an additional directory to expose to the Copilot agent' },
          },
          required: ['prompt'],
        },
      },
      {
        name: TOOLS.EXPLAIN,
        description:
          'Ask GitHub Copilot to explain what a shell command does in plain language.',
        inputSchema: {
          type: 'object',
          properties: {
            command: { type: 'string', description: 'The shell command string to explain' },
            model: { type: 'string', description: 'AI model to use (default: gpt-4.1)' },
            addDir: { type: 'string', description: 'Absolute path to an additional directory to expose to the Copilot agent' },
          },
          required: ['command'],
        },
      },
      {
        name: TOOLS.PING,
        description: 'Verify that the Copilot MCP server is running and responsive.',
        inputSchema: {
          type: 'object',
          properties: {},
          required: [],
        },
      },
    ];
    ```

    **src/server.ts — targeted rename only:**
    - Find: `CodexMcpServer` (class name in declaration and any references within the file)
    - Replace: `CopilotMcpServer`
    - Find: `'Codex MCP Server'` in the server name string (if present as a string literal in setupHandlers or constructor)
    - Replace: `'Copilot MCP Server'`
    - Do NOT change any other logic — only the class name and server name string change.

    **src/index.ts — targeted updates:**
    - Update import: `import { CodexMcpServer } from './server.js'` → `import { CopilotMcpServer } from './server.js'`
    - Update instantiation: `new CodexMcpServer(config)` → `new CopilotMcpServer(config)`
    - Update SERVER_CONFIG.name if it says 'Codex MCP Server' → 'Copilot MCP Server'
    - Do NOT change any other logic.
  </action>
  <verify>
    `npm run build 2>&1` — should succeed with ZERO TypeScript errors (this is the first full build check).
    `grep "CopilotMcpServer" src/server.ts src/index.ts` — found in both files.
    `grep "CodexMcpServer" src/server.ts src/index.ts` — zero results.
    `grep "TOOLS\.ASK\|TOOLS\.SUGGEST\|TOOLS\.EXPLAIN\|TOOLS\.PING" src/tools/definitions.ts` — all four tools referenced.
    `node dist/index.js --help 2>&1 || true` — process starts without crashing on import errors.
  </verify>
  <done>definitions.ts exports 4 tool definitions; server.ts exports CopilotMcpServer; index.ts imports and instantiates CopilotMcpServer; npm run build succeeds with zero errors</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` → exits 0, zero TypeScript errors
2. `grep "CodexMcpServer\|CodexToolHandler\|ReviewToolHandler\|HelpToolHandler\|ListSessionsToolHandler" src/` → zero results
3. `grep "strictExitCode.*true" src/tools/handlers.ts` → found (each handler uses it)
4. `grep "result\.stderr" src/tools/handlers.ts | grep -v "extractResponse"` → zero results (stderr not used as response outside the error-check helper)
5. `grep "COPILOT_BASE_ARGS" src/tools/handlers.ts` → found
6. `grep "validateAddDir" src/tools/handlers.ts` → found
</verification>

<success_criteria>
- npm run build succeeds with zero TypeScript errors
- All four tools (ask, suggest, explain, ping) are implemented as stateless handlers
- copilot binary is invoked with -p flag and all five base flags hardcoded
- stdout is the primary response; non-empty stderr with empty stdout raises ToolExecutionError
- addDir is validated for null bytes, traversal, and absolute path
- No Codex references remain in handlers.ts, definitions.ts, server.ts, or index.ts
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-cli-integration/01-02-SUMMARY.md` using the summary template. Note that npm build now passes, list all handler classes created, and document the stdout/stderr inversion fix and strictExitCode usage.
</output>
