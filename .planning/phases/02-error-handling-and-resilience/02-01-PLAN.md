---
phase: 02-error-handling-and-resilience
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/errors.ts
  - src/utils/command.ts
  - src/tools/handlers.ts
autonomous: true
requirements:
  - CLI-05
  - CLI-06
  - SEC-01
  - SEC-03
  - ERR-01
  - ERR-02
  - ERR-03
  - ERR-04

must_haves:
  truths:
    - "ENOENT from spawn produces a user-readable message with install instructions and the actual binary path — no raw NodeJS.ErrnoException in the MCP response"
    - "Native spawn() timeout of 60 seconds kills the subprocess via SIGTERM and rejects with a timeout error — tool calls cannot hang indefinitely"
    - "Auth tokens (COPILOT_GITHUB_TOKEN, GH_TOKEN, GITHUB_TOKEN) are replaced with [REDACTED] in all error messages and in the stderr console.error log line in command.ts"
    - "ANSI/VT control sequences are stripped from stdout via util.stripVTControlCharacters() before the response reaches the MCP caller"
    - "COPILOT_BINARY_PATH env var overrides the hardcoded 'copilot' string in all three AI handlers — resolved per call, not at module load time"
    - "Non-zero exits classified as quota, auth, ENOENT, or generic — each returning a specific actionable message, not 'Command failed with exit code N'"
    - "npm run build passes with zero TypeScript errors after all changes"
  artifacts:
    - path: "src/errors.ts"
      provides: "scrubTokens() export and updated handleError() with scrubbing"
      contains: "scrubTokens"
    - path: "src/utils/command.ts"
      provides: "ENOENT detection, native timeout, scrubbed stderr logging"
      contains: "ENOENT"
    - path: "src/tools/handlers.ts"
      provides: "getCopilotBinary(), ANSI stripping in extractResponse(), classifyCommandError()"
      contains: "getCopilotBinary"
  key_links:
    - from: "src/utils/command.ts"
      to: "src/errors.ts"
      via: "import scrubTokens"
      pattern: "scrubTokens"
    - from: "src/tools/handlers.ts"
      to: "src/errors.ts"
      via: "import scrubTokens"
      pattern: "scrubTokens"
    - from: "src/tools/handlers.ts"
      to: "node:util"
      via: "import stripVTControlCharacters"
      pattern: "stripVTControlCharacters"
    - from: "src/utils/command.ts"
      to: "spawn timeout option"
      via: "timeout: 60_000 in spawn() call"
      pattern: "timeout.*60"
---

<objective>
Harden all failure modes in the production code: add token scrubbing, ENOENT detection with user-friendly messages, native 60-second spawn timeout, ANSI stripping, COPILOT_BINARY_PATH support, and error classification for quota/auth failures.

Purpose: Phase 1 established basic strictExitCode rejection. Phase 2 makes every failure surface as an actionable message rather than a raw stack trace, and ensures auth tokens never leak into logs or error output.
Output: Three modified source files (errors.ts, command.ts, handlers.ts) with hardened error paths. Build passes with zero TypeScript errors.
</objective>

<execution_context>
@/Users/jonathanborduas/.claude/get-shit-done/workflows/execute-plan.md
@/Users/jonathanborduas/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-error-handling-and-resilience/02-RESEARCH.md
@src/errors.ts
@src/utils/command.ts
@src/tools/handlers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add scrubTokens() to errors.ts and update handleError()</name>
  <files>src/errors.ts</files>
  <action>
Add a `scrubTokens(message: string): string` exported function and update `handleError()` to use it.

Implementation details:

1. Add the token env var list as a module-level const (above the classes):
   ```typescript
   const TOKEN_ENV_VARS = ['COPILOT_GITHUB_TOKEN', 'GH_TOKEN', 'GITHUB_TOKEN'] as const;
   ```

2. Add the exported `scrubTokens` function after the const:
   ```typescript
   export function scrubTokens(message: string): string {
     let scrubbed = message;
     for (const varName of TOKEN_ENV_VARS) {
       const value = process.env[varName];
       if (value && value.length > 4) {
         scrubbed = scrubbed.replaceAll(value, '[REDACTED]');
       }
     }
     return scrubbed;
   }
   ```
   - `value.length > 4` guard prevents scrubbing short/empty strings that could match partial words
   - `replaceAll` is ES2021 / Node 15+ — safe for this project (running Node 25.6.1)
   - Do NOT use regex: value-based replacement handles any token format regardless of prefix

3. Update `handleError()` to apply scrubbing before returning:
   ```typescript
   export function handleError(error: unknown, context: string): string {
     if (error instanceof Error) {
       return scrubTokens(`Error in ${context}: ${error.message}`);
     }
     return scrubTokens(`Error in ${context}: ${String(error)}`);
   }
   ```

No other changes. Do not modify the error classes (ToolExecutionError, CommandExecutionError, ValidationError).
  </action>
  <verify>Run `npm run build` — must exit 0 with zero TypeScript errors</verify>
  <done>
    - `src/errors.ts` exports `scrubTokens` function
    - `handleError()` applies `scrubTokens()` to its return value
    - `npm run build` passes
  </done>
</task>

<task type="auto">
  <name>Task 2: Harden command.ts — ENOENT detection, native timeout, scrub stderr log</name>
  <files>src/utils/command.ts</files>
  <action>
Modify `executeCommand()` in `src/utils/command.ts` to add: (1) import scrubTokens, (2) native spawn timeout, (3) ENOENT detection with user-friendly message, (4) scrub the stderr console.error log line.

Specific changes (do NOT touch `executeCommandStreaming` — it is not used by Copilot handlers):

1. Add import at the top alongside the existing `CommandExecutionError` import:
   ```typescript
   import { CommandExecutionError, scrubTokens } from '../errors.js';
   ```

2. Add a module-level constant for the timeout (place near top, after MAX_BUFFER_SIZE):
   ```typescript
   const EXECUTE_TIMEOUT_MS = 60_000; // 60 seconds (ERR-04)
   ```

3. Update the `spawn()` call inside `executeCommand()` to add `timeout` and `killSignal`:
   ```typescript
   const child = spawn(file, escapedArgs, {
     shell: isWindows,
     env: envOverride ? { ...process.env, ...envOverride } : process.env,
     stdio: ['pipe', 'pipe', 'pipe'],
     timeout: EXECUTE_TIMEOUT_MS,
     killSignal: 'SIGTERM',
   });
   ```
   - Do NOT add timeout to `executeCommandStreaming` — it is a legacy streaming path

4. Update `child.on('close', (code) => { ... })` to add timeout detection BEFORE the existing strictExitCode block:
   ```typescript
   child.on('close', (code, signal) => {
     if (stderr) {
       console.error(chalk.yellow('Command stderr:'), scrubTokens(stderr));
     }

     // Detect timeout: native spawn kills with SIGTERM, close fires with (null, 'SIGTERM')
     if (code === null && signal === 'SIGTERM') {
       reject(
         new CommandExecutionError(
           [file, ...args].join(' '),
           `Command timed out after ${EXECUTE_TIMEOUT_MS}ms`,
           new Error('Timeout')
         )
       );
       return;
     }

     if (options.strictExitCode) {
       // ... existing strictExitCode logic unchanged ...
     } else {
       // ... existing lenient mode logic unchanged ...
     }
   });
   ```
   - Change the callback signature from `(code)` to `(code, signal)` — TypeScript requires `signal: NodeJS.Signals | null`
   - The `scrubTokens(stderr)` call on the console.error line is the only change to the existing close handler body (besides adding timeout detection above it)

5. Update `child.on('error', (error) => { ... })` to detect ENOENT:
   ```typescript
   child.on('error', (error) => {
     const nodeError = error as NodeJS.ErrnoException;
     if (nodeError.code === 'ENOENT') {
       reject(
         new CommandExecutionError(
           file,
           `Binary not found: "${file}". ` +
             `If using the default copilot binary, install it from: https://github.com/github/gh-copilot. ` +
             `If using COPILOT_BINARY_PATH, verify the path is correct.`,
           error
         )
       );
     } else {
       reject(
         new CommandExecutionError(
           [file, ...args].join(' '),
           'Command execution failed',
           error
         )
       );
     }
   });
   ```
   - The ENOENT message includes `file` (not hardcoded 'copilot') to handle both default and COPILOT_BINARY_PATH cases (per research Pitfall 4)
   - Use `as NodeJS.ErrnoException` cast — no import needed, it's a global Node.js type

No changes to `executeCommandStreaming`. No new npm dependencies — `scrubTokens` is from the local errors.ts.
  </action>
  <verify>Run `npm run build` — must exit 0 with zero TypeScript errors. Run `npm test` — all existing tests must still pass (no regressions).</verify>
  <done>
    - `spawn()` call includes `timeout: 60_000, killSignal: 'SIGTERM'`
    - `child.on('close', (code, signal)` — detects SIGTERM timeout and rejects with timeout message
    - `child.on('error', ...)` — detects ENOENT and rejects with install instructions message containing the actual file path
    - `console.error` on stderr line applies `scrubTokens(stderr)` before logging
    - `npm run build` passes, `npm test` passes (42+ tests)
  </done>
</task>

<task type="auto">
  <name>Task 3: Harden handlers.ts — getCopilotBinary(), ANSI stripping, error classification</name>
  <files>src/tools/handlers.ts</files>
  <action>
Three targeted additions to `src/tools/handlers.ts`: (1) `getCopilotBinary()` helper replacing hardcoded 'copilot', (2) ANSI stripping in `extractResponse()`, (3) `classifyCommandError()` in handler catch blocks.

Specific changes:

1. Add import for `stripVTControlCharacters` at the top (alongside existing imports):
   ```typescript
   import { stripVTControlCharacters } from 'node:util';
   ```

2. Add import for `scrubTokens` alongside existing errors import:
   ```typescript
   import { ToolExecutionError, ValidationError, scrubTokens } from '../errors.js';
   ```

3. Add `getCopilotBinary()` helper after the `COPILOT_BASE_ARGS` const:
   ```typescript
   // Resolve binary path per call to support test env overrides (SEC-03)
   function getCopilotBinary(): string {
     return process.env['COPILOT_BINARY_PATH'] ?? 'copilot';
   }
   ```
   - Per-call (not module-level const) so test overrides of `process.env.COPILOT_BINARY_PATH` work

4. Add `classifyCommandError()` helper before `extractResponse()`:
   ```typescript
   // Classify non-zero exit errors into actionable messages (ERR-02, ERR-03, CLI-05)
   function classifyCommandError(error: unknown): string {
     if (!(error instanceof Error)) return 'Unknown error executing copilot';
     const msg = error.message.toLowerCase();
     if (msg.includes('quota') || msg.includes('402') || msg.includes('rate limit')) {
       return 'Copilot quota exceeded. Your GitHub Copilot quota has been exhausted. Please wait before retrying.';
     }
     if (
       msg.includes('auth') || msg.includes('401') || msg.includes('unauthorized') ||
       msg.includes('unauthenticated') || msg.includes('token')
     ) {
       return 'Copilot authentication failed. Ensure COPILOT_GITHUB_TOKEN, GH_TOKEN, or GITHUB_TOKEN is set with a valid GitHub token.';
     }
     if (msg.includes('enoent') || msg.includes('not found') || msg.includes('not installed')) {
       return error.message; // Already user-friendly from command.ts ENOENT detection
     }
     if (msg.includes('timed out')) {
       return error.message; // Already user-friendly from command.ts timeout detection
     }
     return scrubTokens(error.message); // Generic: scrub tokens, pass through
   }
   ```

5. Update `extractResponse()` to strip ANSI before trimming (CLI-06):
   ```typescript
   function extractResponse(stdout: string, stderr: string, toolName: string): string {
     const cleanStdout = stripVTControlCharacters(stdout).trim();
     if (!cleanStdout && stderr) {
       throw new ToolExecutionError(toolName, `Copilot error: ${scrubTokens(stderr)}`);
     }
     return cleanStdout || 'No response from Copilot';
   }
   ```
   - ANSI stripped first, THEN token scrubbing applied to stderr error path (per research Pitfall 5: strip ANSI before scrubbing tokens)

6. Update ALL three AI handler `executeCommand()` calls to use `getCopilotBinary()` (SEC-03):
   - `AskToolHandler`: `await executeCommand(getCopilotBinary(), cmdArgs, undefined, { strictExitCode: true })`
   - `SuggestToolHandler`: `await executeCommand(getCopilotBinary(), cmdArgs, undefined, { strictExitCode: true })`
   - `ExplainToolHandler`: `await executeCommand(getCopilotBinary(), cmdArgs, undefined, { strictExitCode: true })`

7. Update ALL three AI handler catch blocks to use `classifyCommandError()` (CLI-05, ERR-01, ERR-02, ERR-03):
   ```typescript
   // Example for AskToolHandler (same pattern for Suggest and Explain):
   } catch (error) {
     if (error instanceof ValidationError) throw error;
     throw new ToolExecutionError(TOOLS.ASK, classifyCommandError(error), error);
   }
   ```
   - Previously: `'Failed to execute copilot ask'` (generic, not actionable)
   - Now: `classifyCommandError(error)` (quota/auth/ENOENT/timeout-specific messages)

PingToolHandler: no changes needed (does not invoke copilot binary).
  </action>
  <verify>Run `npm run build` — must exit 0. Run `npm test` — all 42+ existing tests must pass.</verify>
  <done>
    - `getCopilotBinary()` function exists and all three AI handlers call it instead of hardcoded 'copilot'
    - `extractResponse()` calls `stripVTControlCharacters(stdout).trim()` before returning
    - `extractResponse()` applies `scrubTokens(stderr)` in the error branch
    - All three AI handler catch blocks call `classifyCommandError(error)` as the ToolExecutionError message
    - `npm run build` passes, `npm test` passes (42+ tests, zero regressions)
  </done>
</task>

</tasks>

<verification>
After all three tasks:

1. `npm run build` exits 0 (zero TypeScript errors)
2. `npm test` passes all 42+ existing tests
3. Grep checks:
   - `grep -n "scrubTokens" src/errors.ts` — shows export function and use in handleError
   - `grep -n "scrubTokens" src/utils/command.ts` — shows import and use on stderr log line
   - `grep -n "ENOENT" src/utils/command.ts` — shows ENOENT detection in error handler
   - `grep -n "SIGTERM" src/utils/command.ts` — shows timeout detection in close handler
   - `grep -n "timeout" src/utils/command.ts` — shows `timeout: EXECUTE_TIMEOUT_MS` in spawn call
   - `grep -n "stripVTControlCharacters" src/tools/handlers.ts` — shows import and use
   - `grep -n "getCopilotBinary" src/tools/handlers.ts` — shows 4+ occurrences (definition + 3 handlers)
   - `grep -n "classifyCommandError" src/tools/handlers.ts` — shows 3+ occurrences (definition + 3 catch blocks)
   - `grep -rn "'copilot'" src/tools/handlers.ts` — must return ZERO results (no hardcoded 'copilot' string remaining in handler execute calls)
</verification>

<success_criteria>
- `scrubTokens()` exported from errors.ts; `handleError()` applies it
- `command.ts` spawn has `timeout: 60_000, killSignal: 'SIGTERM'`; close handler detects `(null, 'SIGTERM')`; error handler detects ENOENT; stderr log line uses `scrubTokens()`
- `handlers.ts` has `getCopilotBinary()` (per-call); `extractResponse()` strips ANSI via `util.stripVTControlCharacters`; `classifyCommandError()` classifies quota/auth/ENOENT/timeout; all three handlers use both helpers
- `npm run build` passes
- `npm test` passes all 42+ tests (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/02-error-handling-and-resilience/02-01-SUMMARY.md`
</output>
